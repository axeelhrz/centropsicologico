import { 
  AlertFormData, 
  AlertActionLog,
  AlertStats,
  AlertType,
  AlertUrgency,
  AlertTrigger,
  ALERT_TYPE_LABELS,
  ALERT_TYPES,
  ALERT_URGENCIES,
  ALERT_TRIGGERS
} from '@/types/alert';
import { FirestoreService } from './firestore';
import { WhatsAppService } from './whatsappService';
import { AIService } from './aiService';

export class AlertService {
  /**
   * Crea una nueva alerta clínica
   */
  static async createAlert(
    centerId: string,
    alertData: AlertFormData,
    createdBy: string,
    autoGenerated: boolean = false,
    sourceSessionId?: string
  ): Promise<string> {
    try {
      const alertId = await FirestoreService.createAlert(centerId, {
        ...alertData,
        autoGenerated,
        sourceSessionId,
        status: 'activa',
        notificationSent: false,
      }, createdBy);

      // Log de creación
      await this.logAlertAction(centerId, alertId, 'created', createdBy, 
        `Alerta creada: ${alertData.description}`);

      // Si es una alerta de alta urgencia, enviar notificación inmediata
      if (alertData.urgency === 'alta' || alertData.urgency === 'crítica') {
        await this.processAlertNotification(centerId, alertId);
      }

      return alertId;
    } catch (error) {
      console.error('Error creating alert:', error);
      throw new Error('No se pudo crear la alerta');
    }
  }

  /**
   * Procesa alertas programadas que han llegado a su fecha
   */
  static async processScheduledAlerts(centerId: string): Promise<void> {
    try {
      const now = new Date();
      const alerts = await FirestoreService.getActiveAlerts(centerId);
      
      for (const alert of alerts) {
        if (alert.scheduledFor && new Date(alert.scheduledFor) <= now && !alert.notificationSent) {
          await this.processAlertNotification(centerId, alert.id);
          
          // Log de activación
          await this.logAlertAction(centerId, alert.id, 'triggered', 'system',
            `Alerta activada automáticamente en fecha programada`);
        }
      }
    } catch (error) {
      console.error('Error processing scheduled alerts:', error);
    }
  }

  /**
   * Detecta síntomas en notas de sesión usando IA
   */
  static async detectSymptomsInSession(
    centerId: string,
    sessionId: string,
    patientId: string,
    notes: string,
    professionalId: string
  ): Promise<void> {
    try {
      // Palabras clave que indican posibles alertas
      const criticalKeywords = [
        'crisis', 'suicidio', 'autolesión', 'agresión', 'violencia',
        'pánico', 'ansiedad severa', 'depresión grave', 'psicosis',
        'alucinaciones', 'delirios', 'ideación suicida'
      ];

      const notesLower = notes.toLowerCase();
      const foundKeywords = criticalKeywords.filter(keyword => 
        notesLower.includes(keyword)
      );

      if (foundKeywords.length > 0) {
        // Crear alerta automática por síntoma detectado
        await this.createAlert(centerId, {
          patientId,
          type: 'síntoma',
          title: 'Síntomas críticos detectados',
          description: `Síntomas detectados en sesión: ${foundKeywords.join(', ')}`,
          trigger: 'texto_IA',
          urgency: 'alta',
          notes: `Detectado automáticamente en sesión ${sessionId}`,
          notificationChannels: ['whatsapp', 'email'],
          metadata: {
            sessionId,
            customData: {
              detectedKeywords: foundKeywords,
              aiConfidence: 0.8
            }
          }
        }, professionalId, true, sessionId);
      }

      // También usar análisis de IA más sofisticado si está disponible
      try {
        const aiAnalysis = await AIService.analyzeSessionNotes(sessionId, notes);
        
        if (aiAnalysis.riskLevel === 'high') {
          await this.createAlert(centerId, {
            patientId,
            type: 'síntoma',
            title: 'Riesgo alto detectado por IA',
            description: `Nivel de riesgo alto detectado: ${aiAnalysis.summary}`,
            trigger: 'texto_IA',
            urgency: 'alta',
            notes: `Análisis de IA - Confianza: ${(aiAnalysis.confidence * 100).toFixed(1)}%`,
            notificationChannels: ['whatsapp', 'email'],
            metadata: {
              sessionId,
              customData: { 
                aiAnalysis,
                aiConfidence: aiAnalysis.confidence
              }
            }
          }, professionalId, true, sessionId);
        }
      } catch (aiError) {
        console.warn('AI analysis not available:', aiError);
      }
    } catch (error) {
      console.error('Error detecting symptoms in session:', error);
    }
  }

  /**
   * Verifica pacientes inactivos y crea alertas
   */
  static async checkPatientInactivity(centerId: string): Promise<void> {
    try {
      const patients = await FirestoreService.getActivePatients(centerId);
      const now = new Date();
      
      for (const patient of patients) {
        const sessions = await FirestoreService.getPatientSessions(centerId, patient.id);
        
        if (sessions.length === 0) continue;
        
        const lastSession = sessions[0]; // Están ordenadas por fecha desc
        const lastSessionDate = new Date(lastSession.date);
        const daysSinceLastSession = Math.floor(
          (now.getTime() - lastSessionDate.getTime()) / (1000 * 60 * 60 * 24)
        );

        // Crear alerta si han pasado más de 30 días sin sesión
        if (daysSinceLastSession > 30) {
          // Verificar si ya existe una alerta de inactividad para este paciente
          const existingAlerts = await FirestoreService.getPatientAlerts(centerId, patient.id);
          const hasInactivityAlert = existingAlerts.some(alert => 
            alert.type === 'inactividad' && alert.status === 'activa'
          );

          if (!hasInactivityAlert) {
            await this.createAlert(centerId, {
              patientId: patient.id,
              type: 'inactividad',
              title: 'Paciente inactivo',
              description: `Paciente sin sesiones por ${daysSinceLastSession} días`,
              trigger: 'falta_sesión',
              urgency: daysSinceLastSession > 60 ? 'alta' : 'media',
              notes: `Última sesión: ${lastSession.date}`,
              notificationChannels: ['email'],
              metadata: {
                customData: { 
                  daysSinceLastSession,
                  lastSessionDate: lastSession.date 
                }
              }
            }, patient.assignedPsychologist, true);
          }
        }
      }
    } catch (error) {
      console.error('Error checking patient inactivity:', error);
    }
  }

  /**
   * Procesa y envía notificaciones para una alerta
   */
  static async processAlertNotification(centerId: string, alertId: string): Promise<void> {
    try {
      const alert = await FirestoreService.getAlert(centerId, alertId);
      if (!alert || alert.notificationSent) return;

      const patient = await FirestoreService.getPatient(centerId, alert.patientId);
      const professional = await FirestoreService.getUser(alert.createdBy);
      
      if (!patient || !professional) return;

      let messageId: string | null = null;

      // Enviar notificación por WhatsApp si está configurado
      if (alert.notificationChannels.includes('whatsapp') && professional.phoneNumber) {
        try {
          messageId = await WhatsAppService.sendProfessionalAlert(
            professional.phoneNumber,
            ALERT_TYPE_LABELS[alert.type],
            patient.fullName,
            alert.description
          );

          await this.logAlertAction(centerId, alertId, 'notification_sent', 'system',
            `Notificación WhatsApp enviada a ${professional.phoneNumber}`);
        } catch (error) {
          await this.logAlertAction(centerId, alertId, 'notification_failed', 'system',
            `Error enviando WhatsApp: ${error instanceof Error ? error.message : 'Error desconocido'}`);
        }
      }

      // Marcar como notificación enviada
      await FirestoreService.updateAlert(centerId, alertId, {
        notificationSent: true,
        whatsappMessageId: messageId || undefined,
        lastTriggered: new Date()
      });

    } catch (error) {
      console.error('Error processing alert notification:', error);
      await this.logAlertAction(centerId, alertId, 'notification_failed', 'system',
        `Error procesando notificación: ${error instanceof Error ? error.message : 'Error desconocido'}`);
    }
  }

  /**
   * Resuelve una alerta
   */
  static async resolveAlert(
    centerId: string,
    alertId: string,
    resolvedBy: string,
    notes?: string
  ): Promise<void> {
    try {
      await FirestoreService.updateAlert(centerId, alertId, {
        status: 'resuelta',
        resolvedBy,
        resolvedAt: new Date(),
        notes: notes || undefined
      });

      await this.logAlertAction(centerId, alertId, 'resolved', resolvedBy,
        notes || 'Alerta marcada como resuelta');
    } catch (error) {
      console.error('Error resolving alert:', error);
      throw new Error('No se pudo resolver la alerta');
    }
  }

  /**
   * Cancela una alerta
   */
  static async cancelAlert(
    centerId: string,
    alertId: string,
    cancelledBy: string,
    reason?: string
  ): Promise<void> {
    try {
      await FirestoreService.updateAlert(centerId, alertId, {
        status: 'cancelada',
        notes: reason || undefined
      });

      await this.logAlertAction(centerId, alertId, 'cancelled', cancelledBy,
        reason || 'Alerta cancelada');
    } catch (error) {
      console.error('Error cancelling alert:', error);
      throw new Error('No se pudo cancelar la alerta');
    }
  }

  /**
   * Registra una acción en el log de alertas
   */
  private static async logAlertAction(
    centerId: string,
    alertId: string,
    action: AlertActionLog['action'],
    performedBy: string,
    details: string,
    metadata?: Record<string, unknown>
  ): Promise<void> {
    try {
      await FirestoreService.createAlertLog(centerId, {
        alertId,
        action,
        performedBy,
        details,
        metadata,
        timestamp: new Date()
      });
    } catch (error) {
      console.error('Error logging alert action:', error);
    }
  }

  /**
   * Crea un objeto con valores por defecto para estadísticas de alertas
   */
  private static createDefaultAlertStats(): AlertStats {
    // Crear objetos con todas las claves requeridas inicializadas en 0
    const byType: Record<AlertType, number> = {} as Record<AlertType, number>;
    ALERT_TYPES.forEach(type => {
      byType[type] = 0;
    });

    const byUrgency: Record<AlertUrgency, number> = {} as Record<AlertUrgency, number>;
    ALERT_URGENCIES.forEach(urgency => {
      byUrgency[urgency] = 0;
    });

    const byTrigger: Record<AlertTrigger, number> = {} as Record<AlertTrigger, number>;
    ALERT_TRIGGERS.forEach(trigger => {
      byTrigger[trigger] = 0;
    });

    return {
      total: 0,
      active: 0,
      resolved: 0,
      cancelled: 0,
      expired: 0,
      highUrgency: 0,
      autoGenerated: 0,
      pendingNotifications: 0,
      byType,
      byUrgency,
      byTrigger
    };
  }

  /**
   * Obtiene estadísticas completas de alertas para un centro
   */
  static async getAlertStats(centerId: string): Promise<AlertStats> {
    try {
      return await FirestoreService.getAlertStats(centerId);
    } catch (error) {
      console.error('Error getting alert stats:', error);
      return this.createDefaultAlertStats();
    }
  }

  /**
   * Obtiene estadísticas básicas de alertas (método legacy)
   */
  static async getBasicAlertStats(centerId: string): Promise<{
    total: number;
    active: number;
    resolved: number;
    highUrgency: number;
    autoGenerated: number;
    pendingNotifications: number;
  }> {
    try {
      const fullStats = await this.getAlertStats(centerId);
      return {
        total: fullStats.total,
        active: fullStats.active,
        resolved: fullStats.resolved,
        highUrgency: fullStats.highUrgency,
        autoGenerated: fullStats.autoGenerated,
        pendingNotifications: fullStats.pendingNotifications
      };
    } catch (error) {
      console.error('Error getting basic alert stats:', error);
      return {
        total: 0,
        active: 0,
        resolved: 0,
        highUrgency: 0,
        autoGenerated: 0,
        pendingNotifications: 0
      };
    }
  }
}