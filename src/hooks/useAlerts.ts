import { useState, useEffect, useCallback, useMemo } from 'react';
import { useAuth } from '@/context/AuthContext';
import { ClinicalAlert, AlertFilters, AlertFormData, AlertStats } from '@/types/alert';
import { FirestoreService } from '@/services/firestore';
import { AlertService } from '@/services/alertService';
import { useSecureCollection } from './useFirestore';
import { where, orderBy, limit, QueryConstraint } from 'firebase/firestore';

export function useAlerts(filters?: AlertFilters) {
  const { user } = useAuth();
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // Memoizar queryConstraints para evitar recreaciones innecesarias
  const queryConstraints: QueryConstraint[] = useMemo(() => {
    const constraints: QueryConstraint[] = [];
    
    if (filters?.status) {
      constraints.push(where('status', '==', filters.status));
    }
    
    if (filters?.type) {
      constraints.push(where('type', '==', filters.type));
    }
    
    if (filters?.urgency) {
      constraints.push(where('urgency', '==', filters.urgency));
    }
    
    if (filters?.patientId) {
      constraints.push(where('patientId', '==', filters.patientId));
    }
    
    if (filters?.createdBy) {
      constraints.push(where('createdBy', '==', filters.createdBy));
    }

    if (filters?.trigger) {
      constraints.push(where('trigger', '==', filters.trigger));
    }

    constraints.push(orderBy('createdAt', 'desc'));
    constraints.push(limit(100)); // Limitar para performance

    return constraints;
  }, [
    filters?.status,
    filters?.type,
    filters?.urgency,
    filters?.patientId,
    filters?.createdBy,
    filters?.trigger
  ]);

  // Memoizar collectionPath para evitar recreaciones
  const collectionPath = useMemo(() => {
    return user?.centerId ? `centers/${user.centerId}/alerts` : '';
  }, [user?.centerId]);
  
  const { 
    data: alerts, 
    loading: collectionLoading, 
    error: collectionError 
  } = useSecureCollection<ClinicalAlert>(
    collectionPath, 
    queryConstraints,
    !!user?.centerId // Solo habilitar si hay centerId
  );

  useEffect(() => {
    setLoading(collectionLoading);
    setError(collectionError?.message || null);
  }, [collectionLoading, collectionError]);

  // Memoizar filtros del lado del cliente para evitar recálculos innecesarios
  const filteredAlerts = useMemo(() => {
    return alerts.filter(alert => {
      if (filters?.search) {
        const searchTerm = filters.search.toLowerCase();
        if (!alert.description.toLowerCase().includes(searchTerm) &&
            !alert.title.toLowerCase().includes(searchTerm) &&
            !alert.notes?.toLowerCase().includes(searchTerm)) {
          return false;
        }
      }

      if (filters?.autoGenerated !== undefined) {
        if (alert.autoGenerated !== filters.autoGenerated) {
          return false;
        }
      }

      if (filters?.dateRange) {
        const alertDate = new Date(alert.createdAt);
        if (filters.dateRange.start && alertDate < new Date(filters.dateRange.start)) {
          return false;
        }
        if (filters.dateRange.end && alertDate > new Date(filters.dateRange.end)) {
          return false;
        }
      }

      return true;
    });
  }, [
    alerts,
    filters?.search,
    filters?.autoGenerated,
    filters?.dateRange
  ]);

  const createAlert = useCallback(async (alertData: AlertFormData) => {
    if (!user?.centerId) throw new Error('No center ID available');
    
    try {
      return await AlertService.createAlert(user.centerId, alertData, user.uid);
    } catch (error) {
      console.error('Error creating alert:', error);
      throw error;
    }
  }, [user]);

  const updateAlert = useCallback(async (alertId: string, alertData: Partial<ClinicalAlert>) => {
    if (!user?.centerId) throw new Error('No center ID available');
    
    try {
      await FirestoreService.updateAlert(user.centerId, alertId, alertData);
    } catch (error) {
      console.error('Error updating alert:', error);
      throw error;
    }
  }, [user]);

  const resolveAlert = useCallback(async (alertId: string, notes?: string) => {
    if (!user?.centerId) throw new Error('No center ID available');
    
    try {
      await AlertService.resolveAlert(user.centerId, alertId, user.uid, notes);
    } catch (error) {
      console.error('Error resolving alert:', error);
      throw error;
    }
  }, [user]);

  const cancelAlert = useCallback(async (alertId: string, reason?: string) => {
    if (!user?.centerId) throw new Error('No center ID available');
    
    try {
      await AlertService.cancelAlert(user.centerId, alertId, user.uid, reason);
    } catch (error) {
      console.error('Error cancelling alert:', error);
      throw error;
    }
  }, [user]);

  const deleteAlert = useCallback(async (alertId: string) => {
    if (!user?.centerId) throw new Error('No center ID available');
    
    try {
      await FirestoreService.deleteAlert(user.centerId, alertId);
    } catch (error) {
      console.error('Error deleting alert:', error);
      throw error;
    }
  }, [user]);

  return {
    alerts: filteredAlerts,
    loading,
    error,
    createAlert,
    updateAlert,
    resolveAlert,
    cancelAlert,
    deleteAlert,
  };
}

export function useRecentAlerts(limit: number = 5) {
  const { user } = useAuth();
  const [alerts, setAlerts] = useState<ClinicalAlert[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    let isMounted = true;

    const fetchRecentAlerts = async () => {
      if (!user?.centerId) {
        if (isMounted) {
          setLoading(false);
          setAlerts([]);
          setError(null);
        }
        return;
      }
      
      try {
        if (isMounted) {
          setLoading(true);
          setError(null);
        }
        
        const recentAlerts = await FirestoreService.getRecentAlerts(user.centerId, limit);
        
        if (isMounted) {
          setAlerts(recentAlerts);
        }
      } catch (err) {
        console.error('Error loading recent alerts:', err);
        if (isMounted) {
          setError(err instanceof Error ? err.message : 'Error loading recent alerts');
          setAlerts([]);
        }
      } finally {
        if (isMounted) {
          setLoading(false);
        }
      }
    };

    // Esperar un poco para asegurar que el usuario esté autenticado
    const timer = setTimeout(fetchRecentAlerts, 200);
    
    return () => {
      isMounted = false;
      clearTimeout(timer);
    };
  }, [user?.centerId, limit]);

  return { alerts, loading, error };
}

export function useAlertStats() {
  const { user } = useAuth();
  const [stats, setStats] = useState<AlertStats>({
    total: 0,
    active: 0,
    resolved: 0,
    cancelled: 0,
    expired: 0,
    highUrgency: 0,
    autoGenerated: 0,
    pendingNotifications: 0,
    byType: {} as Record<string, number>,
    byUrgency: {} as Record<string, number>,
    byTrigger: {} as Record<string, number>
  });
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    let isMounted = true;

    const fetchStats = async () => {
      if (!user?.centerId) {
        if (isMounted) {
          setLoading(false);
        }
        return;
      }
      
      try {
        if (isMounted) {
          setLoading(true);
          setError(null);
        }
        
        const alertStats = await AlertService.getAlertStats(user.centerId);
        
        if (isMounted) {
          setStats(alertStats);
        }
      } catch (err) {
        console.error('Error loading alert stats:', err);
        if (isMounted) {
          setError(err instanceof Error ? err.message : 'Error loading stats');
        }
      } finally {
        if (isMounted) {
          setLoading(false);
        }
      }
    };

    // Esperar un poco para asegurar autenticación
    const timer = setTimeout(fetchStats, 300);
    
    return () => {
      isMounted = false;
      clearTimeout(timer);
    };
  }, [user?.centerId]);

  return { stats, loading, error };
}

export function usePatientAlerts(patientId: string) {
  const { user } = useAuth();
  const [alerts, setAlerts] = useState<ClinicalAlert[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    let isMounted = true;

    const fetchPatientAlerts = async () => {
      if (!user?.centerId || !patientId) {
        if (isMounted) {
          setLoading(false);
          setAlerts([]);
          setError(null);
        }
        return;
      }
      
      try {
        if (isMounted) {
          setLoading(true);
          setError(null);
        }
        
        const patientAlerts = await FirestoreService.getPatientAlerts(user.centerId, patientId);
        
        if (isMounted) {
          setAlerts(patientAlerts);
        }
      } catch (err) {
        console.error('Error loading patient alerts:', err);
        if (isMounted) {
          setError(err instanceof Error ? err.message : 'Error loading patient alerts');
          setAlerts([]);
        }
      } finally {
        if (isMounted) {
          setLoading(false);
        }
      }
    };

    // Esperar un poco para asegurar autenticación
    const timer = setTimeout(fetchPatientAlerts, 200);
    
    return () => {
      isMounted = false;
      clearTimeout(timer);
    };
  }, [user?.centerId, patientId]);

  return { alerts, loading, error };
}

export function useAlertAutomation() {
  const { user } = useAuth();
  const [loading, setLoading] = useState(false);

  const triggerSymptomDetection = useCallback(async (
    sessionId: string,
    patientId: string,
    notes: string
  ) => {
    if (!user?.centerId) throw new Error('No center ID available');
    
    try {
      setLoading(true);
      await AlertService.detectSymptomsInSession(
        user.centerId,
        sessionId,
        patientId,
        notes,
        user.uid
      );
    } catch (error) {
      console.error('Error triggering symptom detection:', error);
      throw error;
    } finally {
      setLoading(false);
    }
  }, [user]);

  const checkInactivity = useCallback(async () => {
    if (!user?.centerId) throw new Error('No center ID available');
    
    try {
      setLoading(true);
      await AlertService.checkPatientInactivity(user.centerId);
    } catch (error) {
      console.error('Error checking inactivity:', error);
      throw error;
    } finally {
      setLoading(false);
    }
  }, [user]);

  const processScheduledAlerts = useCallback(async () => {
    if (!user?.centerId) throw new Error('No center ID available');
    
    try {
      setLoading(true);
      await AlertService.processScheduledAlerts(user.centerId);
    } catch (error) {
      console.error('Error processing scheduled alerts:', error);
      throw error;
    } finally {
      setLoading(false);
    }
  }, [user]);

  return {
    triggerSymptomDetection,
    checkInactivity,
    processScheduledAlerts,
    loading
  };
}